---
import { Table } from "@components/tables/Table";
import * as handlePartidos from "@utils/handle-partidos-table";
import type { Torneo, Partido, Temporada, Equipo } from "@interfaces/index";
import { matchOptions } from "@utils/handle-partidos-table";
import { actions } from "astro:actions";
import Swal from "sweetalert2";

interface Props {
  filter: matchOptions;
}

const { filter }: Props = Astro.props;

const searchParams = Astro.url.searchParams;
const currentPage = Number(searchParams.get("page") ?? 1);
const sortParam = searchParams.get("sortBy") ?? "";
const orderParam = searchParams.get("orderBy") ?? "asc";

const { data: dataMatch, error: errorMatch } = await Astro.callAction(
  actions.getDataByFilter,
  { filter: filter, page: currentPage }
);

if (errorMatch) {
  console.error("Error fetching match data:", errorMatch);
  Swal.fire({
    icon: "error",
    title: "Error al obtener los datos",
    text: errorMatch.message,
  });
}

if (!dataMatch) {
  Swal.fire({
    icon: "warning",
    title: "No se encontraron datos",
    text: "No se pudieron obtener los datos para el filtro seleccionado.",
  });
}

// Mapeo para pasar los arrays a getRows sin condicionales repetitivos
const dataMap: Record<string, any[]> = {
  [matchOptions.torneos]:
    (dataMatch?.torneos as Torneo[] ?? []).sort((a, b) => {
      if (sortParam && orderParam) {
        const fieldA = (a as any)[sortParam];
        const fieldB = (b as any)[sortParam];
        if (fieldA < fieldB) return orderParam === "asc" ? -1 : 1;
        if (fieldA > fieldB) return orderParam === "asc" ? 1 : -1;
      }
      return orderParam === "asc"
        ? a.idtorneo - b.idtorneo
        : b.idtorneo - a.idtorneo;
    }),
  [matchOptions.partidos]:
    (dataMatch?.partidos as Partido[] ?? []).sort((a, b) => {
      if (sortParam && orderParam) {
        const fieldA = (a as any)[sortParam];
        const fieldB = (b as any)[sortParam];
        if (fieldA < fieldB) return orderParam === "asc" ? -1 : 1;
        if (fieldA > fieldB) return orderParam === "asc" ? 1 : -1;
      }
      return orderParam === "asc"
        ? a.idpartido - b.idpartido
        : b.idpartido - a.idpartido;
    }),
  [matchOptions.temporadas]:
    (dataMatch?.temporadas as Temporada[] ?? []).sort((a, b) => {
      if (sortParam && orderParam) {
        const fieldA = (a as any)[sortParam];
        const fieldB = (b as any)[sortParam];
        if (fieldA < fieldB) return orderParam === "asc" ? -1 : 1;
        if (fieldA > fieldB) return orderParam === "asc" ? 1 : -1;
      }
      return orderParam === "asc"
        ? a.idtemporada - b.idtemporada
        : b.idtemporada - a.idtemporada;
    }),
  [matchOptions.equipos]:
    (dataMatch?.equipos as Equipo[] ?? []).sort((a, b) => {
      if (sortParam && orderParam) {
        const fieldA = (a as any)[sortParam];
        const fieldB = (b as any)[sortParam];
        if (fieldA < fieldB) return orderParam === "asc" ? -1 : 1;
        if (fieldA > fieldB) return orderParam === "asc" ? 1 : -1;
      }
      return orderParam === "asc"
        ? a.idequipo - b.idequipo
        : b.idequipo - a.idequipo;
    }),
};

// Helper para llamar getRows siempre con los 4 argumentos (pueden ser [])
const buildRows = (option: matchOptions) =>
  handlePartidos.getRows(
    option,
    dataMap[matchOptions.torneos],
    dataMap[matchOptions.partidos],
    dataMap[matchOptions.temporadas],
    dataMap[matchOptions.equipos]
  );

const headers = handlePartidos.getHeaders(filter);
const rows = buildRows(filter);
---

<div id="tables-container" class="w-full space-y-10">
  <section id={`table-${filter}`} class={`w-full`}>
    <h2 class="text-xl font-semibold mb-2">{filter}</h2>

    {
      rows.length > 0 ? (
        <div class="flex rounded-md w-full h-fit self-center overflow-x-auto">
          <Table headers={headers}>
            {rows.map((row, rowIndex) => (
              <tr
                class="border-b odd:bg-gray-50 hover:bg-gray-100 transition-colors"
                id={`match-${filter.toLowerCase()}-${row[0]?.data ?? rowIndex}`}
              >
                {row.map((cell, _) =>
                  cell.isVisible === false ? null : (
                    <td class="px-6 py-4">{cell.data}</td>
                  )
                )}

                {handlePartidos
                  .getActions(filter, (id: number) =>
                    console.log(`${filter} con id ${id} eliminado`)
                  )
                  .map((action, actionIndex) =>
                    action.type === "link" ? (
                      <td class="px-6 py-4 text-start">
                        <a
                          class="cursor-pointer"
                          href={`${action.href ?? ""}${row[0]?.data ?? ""}`}
                          title={action.alt}
                        >
                          <img
                            class="size-6"
                            src={action.icon}
                            alt={action.alt}
                          />
                        </a>
                      </td>
                    ) : (
                      <td class="px-6 py-4 text-start">
                        <button
                          type="button"
                          data-id={row[0]?.data ?? ""}
                          class="cursor-pointer"
                          title={action.alt}
                        >
                          <img
                            class="size-6"
                            src={action.icon}
                            alt={action.alt}
                          />
                        </button>
                      </td>
                    )
                  )}
              </tr>
            ))}
          </Table>
        </div>
      ) : (
        <p class="text-gray-500 mt-10">
          No hay {filter.toLowerCase()} registrados.
        </p>
      )
    }
  </section>
</div>
<script>
  import { privateRoutesMap } from "@consts/routes";
  import { MatchOptionClient, matchOptions } from "@utils/index";
  import { actions } from "astro:actions";
  import { navigate } from "astro:transitions/client";
  import Swal from "sweetalert2";

  const handleDelete = async (id: number) => {
    const selectedFilter = await MatchOptionClient.getFilter();

    switch (selectedFilter) {
      case matchOptions.torneos:
        const { data, error } = await actions.deleteTorneo({ idtorneo: id });
        if (error) {
          console.error("Error deleting torneo:", error);
          Swal.fire("Error", error.message, "error");
        } else {
          Swal.fire("Éxito", "Torneo eliminado", "success").then(
            async (result) => {
              if (result.isConfirmed) {
                await navigate(privateRoutesMap.ADMIN_PARTIDOS);
              }
            }
          );
        }
        break;
      case matchOptions.partidos:
        console.log(`Partido con id ${id} eliminado`);
        const { data: partidoData, error: partidoError } =
          await actions.deletePartido({ idpartido: id });
        if (partidoError) {
          console.error("Error deleting partido:", partidoError);
          Swal.fire("Error", partidoError?.message, "error");
        } else {
          Swal.fire("Éxito", "Partido eliminado", "success").then(
            async (result) => {
              if (result.isConfirmed) {
                await navigate(privateRoutesMap.ADMIN_PARTIDOS);
              }
            }
          );
        }
        break;
      case matchOptions.temporadas:
        console.log(`Temporada con id ${id} eliminado`);
        const { data: temporadaData, error: temporadaError } =
          await actions.deleteTemporada({ idtemporada: id });
        if (temporadaError) {
          console.error("Error deleting temporada:", temporadaError);
          Swal.fire("Error", temporadaError?.message, "error");
        } else {
          Swal.fire("Éxito", "Temporada eliminada", "success").then(
            async (result) => {
              if (result.isConfirmed) {
                await navigate(privateRoutesMap.ADMIN_PARTIDOS);
              }
            }
          );
        }
        break;
      case matchOptions.equipos:
        console.log(`Equipo con id ${id} eliminado`);
        const { data: equipoData, error: equipoError } =
          await actions.deleteEquipo({ idequipo: id });
        if (equipoError) {
          console.error("Error deleting equipo:", equipoError);
          Swal.fire("Error", equipoError?.message, "error");
        } else {
          Swal.fire("Éxito", "Equipo eliminado", "success").then(
            async (result) => {
              if (result.isConfirmed) {
                await navigate(privateRoutesMap.ADMIN_PARTIDOS);
              }
            }
          );
        }
        break;
      default:
        console.warn("Opción de filtro no reconocida para eliminación");
    }
  };

  // Se ejecuta cuando la página ya cargó
  document.addEventListener("astro:page-load", async () => {
    console.log("Astro page loaded: listening for filter changes...");
    const deleteButtons = document.querySelectorAll("button[data-id]");
    deleteButtons.forEach((button) => {
      button.addEventListener("click", async () => {
        const id = button.getAttribute("data-id");
        console.log("Delete button clicked for id:", id);
        if (!id) return;
        await handleDelete(Number(id));
      });
    });

    window.addEventListener("partidos:filter-changed", async () => {
      console.log("Filter changed event detected in PartidosProfesorTable");

      const tablesContainer = document.getElementById("tables-container");
      if (!tablesContainer) return;

      const selectedFilter = await MatchOptionClient.getFilter();

      for (const section of tablesContainer.children) {
        if (section.id === `table-${selectedFilter}`) {
          section.classList.remove("hidden");
        } else {
          section.classList.add("hidden");
        }
      }
    });
  });
</script>
